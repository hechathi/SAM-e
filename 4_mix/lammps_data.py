#!/usr/bin/python
#h
#h		
#hv			lms_data version 1.0 (04 Oct 2017)
#h	----------- Msi force field handler  ----------------
#h
#h	By Hernan Chavez Thielemann
#h	herchavezt@gmail.com
#h	
#
#	Ver		 Filename		  Date			Coments
#	---		--------------	----------	-------------------------------------------
#	1.0 	lammps_data.py	04/10/2017	new, in order to neat moler.py
#h
import os
import sys

import ff_scout
from packmoler import fileseeker

#------------------------------------------------------
#///////	Class definitions are here	///////
#------------------------------------------------- -----

#------------------------------------------------------
#///////	Function definitions are here	///////
#------------------------------------------------------

def _write(mol_obs, mol_qty, box_vars, pdb_coordfl):
	''' self explanatory, in reference to the module name'''
	# trying to make it in an ordered way
	from moler import text2file
	
	header, topo_info= create_header(mol_obs, mol_qty, box_vars)
	
	ff_coefs= create_ffcoeffs_class2(topo_info)
	
	body = create_body(mol_obs, mol_qty, pdb_coordfl, topo_info)
	
	texto= header+ff_coefs+body
	
	new_fname = '{}'.format(pdb_coordfl)
	if '/'in new_fname:
		new_fname = new_fname.split('/')[-1]
	new_fname='data.'+new_fname.split('.')[0]
	text2file(new_fname, texto, False)
	msg=" Lammps data file created as "+new_fname
	print "\n"+"-"*(len(msg)+1)+"\n"+msg+"\n"+"-"*(len(msg)+1)+"\n"
	
	doneflag=False
	dir_path = os.path.dirname(os.path.realpath( __file__))
	if len(fileseeker(dir_path,new_fname))>0:
		doneflag=True
	return doneflag

def create_header(mol_objects,mol_qty,box_v):
	''' creates the clasic header of lammps data, as this is intended to work
	with polimers triclinic cell is not an option, mybe in future ;).'''
	atoms		=	0
	bonds		=	0
	angles		=	0
	dihedrals	=	0
	impropers	=	0
	atoms_types	=	[]
	bonds_types	=	[]
	angles_types=	[]
	dihedral_types=	[]
	improper_types=	[]
	for m in range(len(mol_objects)):
		
		qty	=	mol_qty[m][0]
		atoms	+=	len(mol_objects[m]._atom_props)*qty
		bonds	+=	len(mol_objects[m]._bond_props)*qty
		angles	+=	len(mol_objects[m]._angl_props)*qty
		dihedrals+=	len(mol_objects[m]._dihe_props)*qty
		impropers+=	len(mol_objects[m]._impr_props)*qty
		topology	=	mol_objects[m].topo
		
		atoms_types		=	add_ifnotinthere(topology[0], atoms_types)
		bonds_types		=	add_ifnotinthere(topology[1], bonds_types)
		angles_types	=	add_ifnotinthere(topology[2], angles_types)
		dihedral_types	=	add_ifnotinthere(topology[3], dihedral_types)
		improper_types	=	add_ifnotinthere(topology[4], improper_types)
		
		
	pk_vrs=[ float(box_v[x]) for x in range(len(box_v))]
	mincoox= pk_vrs[3]- pk_vrs[0]/2
	mincooy= pk_vrs[4]- pk_vrs[1]/2
	mincooz= pk_vrs[5]- pk_vrs[2]/2
	maxcoox= pk_vrs[3]+ pk_vrs[0]/2
	maxcooy= pk_vrs[4]+ pk_vrs[1]/2
	maxcooz= pk_vrs[5]+ pk_vrs[2]/2
	
	
	# the section that transforms that in the header
	hed='LAMMPS data file. atom_style full. generated by MIXER v'+version()
	hed+='\n '
	hed+='\n {} atoms'.format(atoms)
	hed+='\n {} bonds'.format(bonds)
	hed+='\n {} angles'.format(angles)
	hed+='\n {} dihedrals'.format(dihedrals)
	hed+='\n {} impropers'.format(impropers)
	hed+='\n '
	hed+='\n {} atom types'.format(len(atoms_types))
	hed+='\n {} bond types'.format(len(bonds_types))
	hed+='\n {} angle types'.format(len(angles_types))
	hed+='\n {} dihedral types'.format(len(dihedral_types))
	hed+='\n {} improper types'.format(len(improper_types))
	hed+='\n '
	hed+='\n {:.4f} {:.4f}  xlo xhi'.format(mincoox, maxcoox)
	hed+='\n {:.4f} {:.4f}  ylo yhi'.format(mincooy, maxcooy)
	hed+='\n {:.4f} {:.4f}  zlo zhi'.format(mincooz, maxcooz)
	hed+='\n '
	info=[sorted( atoms_types), sorted( bonds_types), sorted( angles_types),
		  sorted( dihedral_types), sorted( improper_types)]
	return hed, info

def add_ifnotinthere(new_el_list, base_list):
	''' if the item in new elements list is not in the base list is added'''
	for x in range(len( new_el_list)):
		if new_el_list[x] not in base_list:
			base_list.append( new_el_list[x])
	return	base_list

def create_ffcoeffs_class2(topo_i):
	''' manage the info to put together the required coeffs'''
	atom_info		= topo_i[0][:]
	bonds_info		= topo_i[1][:]
	angles_info		= topo_i[2][:]
	dihedral_info	= topo_i[3][:]
	improper_info	= topo_i[4][:]
	
	
	ff_lines='\n Pair Coeffs # lj/class2/coul/long\n'
	eps, r = ff_scout.get_lj96(atom_info)
	for at in range(len(topo_i[0])):
		ff_lines+= '\n{} {} {} # {}'.format(at+1, eps[at], r[at], topo_i[0][at])
	ff_lines+='\n'
	bonds_radius=[]
	if len(bonds_info)<>[]:#	----------if there is at least one Bond
		ff_lines+='\n Bond Coeffs # class2\n'
		R0, K2, K3, K4 = ff_scout.get_bond_ks(bonds_info)
		for bn in range(len(topo_i[1])):
			ff_lines+= '\n{} {} {} {} {} # {}'.format(
				bn+1, R0[bn], K2[bn], K3[bn], K4[bn], bonds_info[bn])
			bonds_radius.append([bonds_info[bn], R0[bn]])
		ff_lines+='\n'
	
	if len(angles_info)<>[]:#	----------if there is at least one Angle
		
		ff_lines+='\n Angle Coeffs # class2\n'
		theta0, K2, K3, K4= ff_scout.get_angle_ks(angles_info)
		for an in range(len(angles_info)):
			ff_lines+= '\n{} {} {} {} {} # {}'.format(
				an+1, theta0[an], K2[an], K3[an], K4[an], angles_info[an])
		ff_lines+='\n'
		
		ff_lines+='\n BondBond Coeffs\n'
		Kbb, Rb0, Rb0p = ff_scout.get_angle_bb_Ks(angles_info, bonds_radius)
		for an in range(len(angles_info)):
			ff_lines+= '\n{} {} {} {} # {}'.format(
				an+1, Kbb[an], Rb0[an], Rb0p[an], angles_info[an])
		ff_lines+='\n'
		
		ff_lines+='\n BondAngle Coeffs\n'
		Kbtheta, Kbptheta= ff_scout.get_angle_ba_Ks(angles_info)
		for an in range(len(angles_info)):
			ff_lines+= '\n{} {} {} {} {} # {}'.format(
				an+1, Kbtheta[an], Kbptheta[an], Rb0[an], Rb0p[an], angles_info[an])
		ff_lines+='\n'
		
	if len(dihedral_info)<>[]:#	----------if there is at least one Dihedral
		
		ff_lines+='\n Dihedral Coeffs # class2\n'
		V1, Phi01, V2, Phi02, V3, Phi03= ff_scout.get_dihedral_ks(dihedral_info)
		for dh in range(len(dihedral_info)):
			ff_lines+= '\n{} {} {} {} {} {} {}# {}'.format(
				dh+1, V1[dh], Phi01[dh], V2[dh], Phi02[dh], 
				V3[dh], Phi03[dh], dihedral_info[dh])
		ff_lines+='\n'
		
		ff_lines+='\n EndBondTorsion Coeffs\n'
		F1d, F2d, F3d, F1i, F2i, F3i, R0e = ff_scout.get_dihedral_ebt_ks(
											dihedral_info, bonds_radius)
		for dh in range(len(dihedral_info)):
				ff_lines+= '\n{} {} {} {} {} {} {} {} {} # {}'.format(
					dh+1, F1d[dh], F2d[dh], F3d[dh], F1i[dh], F2i[dh], F3i[dh],
					R0e[dh][0], R0e[dh][2], dihedral_info[dh])
		ff_lines+='\n'
		
		ff_lines+='\n MiddleBondTorsion Coeffs\n'
		F1, F2, F3 = ff_scout.get_dihedral_mbt_ks( dihedral_info)
		for dh in range(len(dihedral_info)):
			try:
				vli= [dh+1, F1[dh], F2[dh], F3[dh],R0e[dh][1], dihedral_info[dh]]
			except TypeError:
				print ff_scout.wrg_y('ld line 197 > '+dihedral_info[dh]), 
				print F1[dh], F2[dh], F3[dh], R0[dh]
				vli= [dh+1, F1[dh], F2[dh], F3[dh],R0e[dh], dihedral_info[dh]]
			ff_lines+= '\n{} {} {} {} {} # {}'.format(*vli)
		ff_lines+='\n'
		

		
				
		
		
		
		
		'''
		ff_lines+='\n AngleAngleTorsion Coeffs\n'
		Kbb, Rb0, Rb0p = ff_scout.get_angle_bb_Ks(dihedral_info, bonds_radius)
		for an in range(len(angles_info)):
			ff_lines+= '\n{} {} {} {} # {}'.format(
				an+1, Kbb[an], Rb0[an], Rb0p[an], angles_info[an])
		ff_lines+='\n'
		

		'''
		'''
		ff_lines+='\n BondBond13 Coeffs\n'
		#Kbtheta, Kbptheta= ff_scout.get_angle_ba_Ks(angles_info)
		for an in range(len(angles_info)):
			ff_lines+= '\n{} {} {} {} {} # {}'.format(
				an+1, Kbtheta[an], Kbptheta[an], Rb0[an], Rb0p[an], angles_info[an])
		ff_lines+='\n'
		
		ff_lines+='\n AngleTorsion Coeffs\n'
		#Kbtheta, Kbptheta= ff_scout.get_angle_ba_Ks(angles_info)
		for an in range(len(angles_info)):
			ff_lines+= '\n{} {} {} {} {} # {}'.format(
				an+1, Kbtheta[an], Kbptheta[an], Rb0[an], Rb0p[an], angles_info[an])
		ff_lines+='\n'
		'''
	if len(improper_info)<>[]:#	----------if there is at least one W-oop
		pass
		
	#print ff_lines
	return ff_lines

def create_body( mol_objects, mol_qty, pdb_file, gb_topo):
	''' creates the coordinate lammps data file topology part'''
	atom_type_dic={}
	bond_type_dic={}
	angl_type_dic={}
	dihe_type_dic={}
	impr_type_dic={}
	#print '...'
	#for x in range(len(gb_topo)):
	#	print gb_topo[x]
	atom_info,bonds_info,angles_info,dihedral_info,improper_info= gb_topo
	'''new dictionary constructors'''
	for at in range(len(atom_info)):
		atom_type_dic[atom_info[at]]=str(at+1)
	for bn in range(len(bonds_info)):
		bond_type_dic[bonds_info[bn]]=str(bn+1)
	for an in range(len(angles_info)):
		angl_type_dic[angles_info[an]]=str(an+1)
	for dh in range(len(dihedral_info)):
		dihe_type_dic[dihedral_info[dh]]=str(dh+1)
	for ip in range(len(improper_info)):
		impr_type_dic[improper_info[ip]]=str(ip+1)
	''' body construction'''
	bdy='\n'
	
	# Masses section each type one mass
	malines=' Masses\n\n'
	#print pdb_file
	for at in range(len(atom_info)): # here just to mantain order, I know that could be in the upper cycle
		atty= atom_info[at]
		atmass= ff_scout.typeatom_mass(atty)
		malines+= '{} {} # {}\n'.format(at+1, atmass, atty)
	malines+= '\n'
		
	# Atom section
	atlines=' Atoms\n\n'
	mol_id=0
	bf_aid=0 # buffer of atom id
	bf_mnm=0 # buffer of molecule number
	bf_mid=0
	with open(pdb_file, 'r')  as inpdb:
		for k_line in inpdb:
			if k_line.startswith("ATOM"):
				# read line 
				aid=(int(k_line[6:11]))
				aknd=((k_line[12:16]))
				mol_num=(int(k_line[23:26]))
				Cx=(float(k_line[30:38]))
				Cy=(float(k_line[39:46]))
				Cz=(float(k_line[47:54]))
				# change of mol? let's buffer it
				mol_id	=	(ord(k_line[19])-ord('A'))
				if mol_num<>bf_mnm or mol_id<>bf_mid:
					bf_aid	=	aid
					bf_mid	=	mol_id
				
				try: 
					atty, atchg = mol_objects[mol_id]._atom_props[aid-bf_aid][1:]
				except IndexError:
					print k_line
					print mol_id, aid-bf_aid
			
				atlines	+=	'{} {} {} {:5.4f} {:6.3f} {:6.3f} {:6.3f} # {}\n'.format(
				aid, mol_num, atom_type_dic[atty], atchg, Cx, Cy, Cz, aknd	) 
				
				bf_mnm=mol_num
	atlines	+= '\n'
	# Bonds section
	bolines=' Bonds\n\n'
	bf_aid=0 # buffer of atom id
	bd_id=1
	aux= 0
	for x in range(len(mol_objects)):
		molx_bprop=mol_objects[x]._bond_props# type -id1 id2
		at_num=len(mol_objects[x].atoms)
		qty	= mol_qty[x][0]
		
		for y in range(qty):
			
			for z in range(len(molx_bprop)):
				bndty=bond_type_dic[molx_bprop[z][0]]
				aid1=int(molx_bprop[z][1])+bf_aid
				aid2=int(molx_bprop[z][2])+bf_aid
				bolines+=	'{} {} {} {}\n'.format(
						bd_id, bndty, aid1, aid2)
				bd_id+=1
			
		bf_aid+=at_num
	bolines	+= '\n'
	if len(bolines.split('\n'))==4:
		bolines=''
	
	# Angles section
	anlines=' Angles\n\n'
	bf_aid=0# buffer of atom id
	an_id=1
	
	for x in range(len(mol_objects)):
		molx_aprop=mol_objects[x]._angl_props# type -id1 id2
		at_qty=len(mol_objects[x].atoms)
		qty	= mol_qty[x][0]
		
		for y in range(qty):
			
			for z in range(len(molx_aprop)):
				angty= angl_type_dic[molx_aprop[z][0]] 
				aid1= int(molx_aprop[z][1])+ bf_aid
				aid2= int(molx_aprop[z][2])+ bf_aid
				aid3= int(molx_aprop[z][3])+ bf_aid
				anlines+=	'{} {} {} {} {}\n'.format(
						an_id, angty, aid1, aid2, aid3)
				an_id+=1
			
			bf_aid+= at_qty
			
	anlines	+= '\n'
	if len(anlines.split('\n'))==4:
		anlines=''
	
	# Dihedrals section
	dilines=' Dihedrals\n\n'
	bf_aid=0# buffer of atom id
	dh_id=1
	
	for x in range(len(mol_objects)):
		molx_dprop=mol_objects[x]._dihe_props# type -id1 id2
		at_qty=len(mol_objects[x].atoms)
		qty	= mol_qty[x][0]
		
		for y in range(qty):
			
			for z in range(len(molx_dprop)):
				dihty= dihe_type_dic[molx_dprop[z][0]] 
				aid1= int(molx_dprop[z][1])+ bf_aid
				aid2= int(molx_dprop[z][2])+ bf_aid
				aid3= int(molx_dprop[z][3])+ bf_aid
				aid4= int(molx_dprop[z][3])+ bf_aid
				dilines+=	'{} {} {} {} {} {}\n'.format(
						dh_id, dihty, aid1, aid2, aid3, aid4)
				dh_id+=1
			
			bf_aid+= at_qty
			
	dilines	+= '\n'
	if len(dilines.split('\n'))==4:
		dilines=''
	
	# Impropers section
	imlines=' Impropers\n\n'

	bf_aid=0# buffer of atom id
	im_id=1
	
	for x in range(len(mol_objects)):
		molx_iprop=mol_objects[x]._impr_props# type -id1 id2
		at_qty=len(mol_objects[x].atoms)
		qty	= mol_qty[x][0]
		
		for y in range(qty):
			
			for z in range(len(molx_iprop)):
				impty= impr_type_dic[molx_iprop[z][0]] 
				aid1= int(molx_iprop[z][1])+ bf_aid
				aid2= int(molx_iprop[z][2])+ bf_aid
				aid3= int(molx_iprop[z][3])+ bf_aid
				aid4= int(molx_iprop[z][3])+ bf_aid
				imlines+=	'{} {} {} {} {} {}\n'.format(
						im_id, impty, aid1, aid2, aid3, aid4)
				im_id+=1
			
			bf_aid+= at_qty
	imlines	+= '\n'
	if len(imlines.split('\n'))==4:
		imlines=''
	
	bdy+= malines+ atlines+ bolines+ anlines+ dilines+ imlines
	
	return bdy

def version():
	'''file version'''
	dir_path = os.path.dirname(os.path.realpath(__file__))
	with open(dir_path+"/lammps_data.py", 'r')  as indata:
		for j_line in indata:
			if j_line.startswith("#hv"):
				_ver= j_line[23:27]
				break
	return _ver

if __name__ == "__main__":
	'''Testing zone, the idea is to reach this file 
	throught mixer or SAM-e GUI'''
	
	fake_files=['/home/hernan/Desktop/Models/cnt55077.pdb',
				'/home/hernan/Desktop/Models/DGEBA_n.pdb',
				'/home/hernan/Desktop/Models/DETA_n.pdb']
	fake_mol_vars=['0.5;0.5;0.5','200','2/5']
	fake_packing_vars=['1.09','42.38567','31.04726','31.04726',
					   '78.997','0.5','0.5','0.5']
	
	version='2.0'
